/*******************************************************************************
 *
 * REVISION:
 * - TIMER-BASED DELAY: Replaced the NOP-based blocking delay with a more
 * accurate, timer-based (CTM) blocking delay for microsecond-level timing.
 * - HARDWARE IR CARRIER: Replaced the software-based, blocking IR pulse
 * generation with a hardware-timed STM (Standard Timer Module) solution. This
 * creates a precise ~37kHz carrier wave without consuming CPU cycles for the
 * toggling logic itself, improving timing accuracy and efficiency.
 * - FINAL 7-SEGMENT MAPPING: Implemented the definitive 7-segment display
 * logic based on the user-provided map of individual LEDs which form the
 * shapes of the segments. The "upside down" orientation is also handled.
 * - CORRECTED 7-SEGMENT DIGIT ORDER: Created a clear mapping array to set
 * which hardware section corresponds to which place value (1s, 10s, etc.).
 * - SWIPE-TO-POWER CONTROL: A right-to-left swipe now powers the system on,
 * and a left-to-right swipe powers it off with a reverse animation.
 *
 ******************************************************************************/

#include "BS84D20CA.h"
#include "USER_PROGRAM_C.INC"

// --- PIN CONFIGURATION & MASKS ---
#define SCLK_PORT       _pc6
#define SCLK_PORT_CTRL  _pcc6
#define DIN_PORT        _pc7
#define DIN_PORT_CTRL   _pcc7
#define IR_EMITTER_PORT _pc0
#define IR_EMITTER_CTRL _pcc0
#define IR_RECEIVER_1   _pc3 // Left Receiver
#define IR_RECEIVER_2   _pc2 // Right Receiver
#define KEY_MASK_K1 (1 << (20 - 17))
#define KEY_MASK_K2 (1 << (10 - 9))
#define KEY_MASK_K3 (1 << (19 - 17))
#define KEY_MASK_K4 (1 << (1 - 1))
#define KEY_MASK_K5 (1 << (2 - 1))
#define KEY_MASK_K6 (1 << (3 - 1))

// --- APPLICATION & TM1640 CONSTANTS ---
#define PTM_INTERRUPT_FREQ 1000
#define TICKS_PER_APP_TICK 20
#define HEARTBEAT_INTERVAL 25
#define SEVEN_SEG_AUTO_INTERVAL 50
#define SEVEN_SEG_MAX_VALUE 1600
#define SEVEN_SEG_STEP 100
enum { GESTURE_IDLE, GESTURE_ARMED_R1, GESTURE_ARMED_R2 };
#define GESTURE_TIMEOUT  15
#define GESTURE_COOLDOWN 25
enum { K1_STATE_OFF, K1_STATE_INSTANT_ON, K1_STATE_SEQUENTIAL_ON, K1_STATE_FULLY_ON, K1_STATE_SEQUENTIAL_OFF };
#define K1_SEQUENTIAL_DELAY 4
#define CMD_DATA_AUTO_INC   0x40
#define CMD_ADDRESS_SET     0xC0
#define CMD_DISPLAY_ON_LOW  0x88
#define CMD_DISPLAY_ON_MED  0x8B
#define CMD_DISPLAY_ON_HIGH 0x8F

// --- LED COORDINATE DEFINITIONS ---
typedef struct { unsigned char seg; unsigned char grid; } LedCoord;
const LedCoord instantOnLeds[] = { {3, 8}, {1, 8}, {4, 8}, {2, 8}, {5, 8}, {0, 8} };
const LedCoord sequentialOnLeds[] = { {5, 14}, {4, 14}, {4, 6}, {1, 6}, {2, 6}, {3, 6}, {0, 6}, {4, 7}, {5, 7}, {4, 1}, {5, 1}, {4, 10}, {5, 10}, {3, 5}, {1, 5}, {2, 5}, {4, 5}, {0, 5}, {5, 5}, {0, 2}, {3, 2}, {2, 2}, {1, 2}, {4, 2}, {5, 13} };
const LedCoord exceptionLeds[] = { {3, 14}, {3, 10}, {3, 1}, {3, 7}, {3, 13}, {3, 12}, {3, 11}, {1, 14}, {1, 10}, {1, 1}, {1, 7}, {1, 13}, {1, 12}, {1, 11}, {2, 14}, {2, 10}, {2, 1}, {2, 7}, {2, 13}, {2, 12}, {2, 11}, {0, 14}, {0, 10}, {0, 1}, {0, 7}, {0, 13}, {0, 12}, {0, 11}, {5, 11} };

// --- FINAL 7-SEGMENT MAPPING (Based on user-provided map) ---
const LedCoord d1_sA = {1, 14}; const LedCoord d1_sB = {1, 13}; const LedCoord d1_sC = {1, 1};  const LedCoord d1_sD = {1, 10}; const LedCoord d1_sE = {1, 7};  const LedCoord d1_sF = {1, 12}; const LedCoord d1_sG = {1, 11};
const LedCoord d2_sA = {2, 14}; const LedCoord d2_sB = {2, 13}; const LedCoord d2_sC = {2, 1};  const LedCoord d2_sD = {2, 10}; const LedCoord d2_sE = {2, 7};  const LedCoord d2_sF = {2, 12}; const LedCoord d2_sG = {2, 11};
const LedCoord d3_sA = {3, 14}; const LedCoord d3_sB = {3, 13}; const LedCoord d3_sC = {3, 1};  const LedCoord d3_sD = {3, 10}; const LedCoord d3_sE = {3, 7};  const LedCoord d3_sF = {3, 12}; const LedCoord d3_sG = {3, 11};
const LedCoord d4_sA = {0, 14}; const LedCoord d4_sB = {0, 13}; const LedCoord d4_sC = {0, 1};  const LedCoord d4_sD = {0, 10}; const LedCoord d4_sE = {0, 7};  const LedCoord d4_sF = {0, 12}; const LedCoord d4_sG = {0, 11};

const LedCoord* const all_seven_seg_leds[] = {
    &d1_sA, &d1_sB, &d1_sC, &d1_sD, &d1_sE, &d1_sF, &d1_sG, &d2_sA, &d2_sB, &d2_sC, &d2_sD, &d2_sE, &d2_sF, &d2_sG,
    &d3_sA, &d3_sB, &d3_sC, &d3_sD, &d3_sE, &d3_sF, &d3_sG, &d4_sA, &d4_sB, &d4_sC, &d4_sD, &d4_sE, &d4_sF, &d4_sG
};
const LedCoord* const digit_a_map[7] = { &d1_sD, &d1_sE, &d1_sF, &d1_sA, &d1_sB, &d1_sC, &d1_sG };
const LedCoord* const digit_b_map[7] = { &d2_sD, &d2_sE, &d2_sF, &d2_sA, &d2_sB, &d2_sC, &d2_sG };
const LedCoord* const digit_c_map[7] = { &d3_sD, &d3_sE, &d3_sF, &d3_sA, &d3_sB, &d3_sC, &d3_sG };
const LedCoord* const digit_d_map[7] = { &d4_sD, &d4_sE, &d4_sF, &d4_sA, &d4_sB, &d4_sC, &d4_sG };

const LedCoord* const* const digit_place_map[4] = {
    digit_b_map, // Position 2 (Tens place)
    digit_a_map, // Position 3 (Ones place)
    digit_d_map, // Position 0 (Thousands place)
    digit_c_map  // Position 1 (Hundreds place)
};

const unsigned char seven_seg_font[] = { 0b0111111, 0b0000110, 0b1011011, 0b1001111, 0b1100110, 0b1101101, 0b1111101, 0b0000111, 0b1111111, 0b1101111 };

// --- GLOBAL VARIABLES & FORWARD DECLARATIONS ---
unsigned char displayBuffer[16];
volatile unsigned char app_tick_flag = 0;
unsigned char gesture_state = GESTURE_IDLE;
unsigned char gesture_timeout_counter = 0;
unsigned char gesture_cooldown_counter = 0;
volatile unsigned char key_flags[6] = {0};
volatile unsigned char k1_state = K1_STATE_OFF;
unsigned char k1_sequential_index = 0;
unsigned char k1_delay_counter = 0;
unsigned char brightness_level = 2;
volatile unsigned char seven_seg_mode_on = 0;
unsigned int seven_seg_value = 0;
unsigned char seven_seg_autoincrement_counter = 0;

void configure_system_clock(void);
void configure_io_pins(void);
void init_PTM_for_tick(void);
void init_STM_for_carrier(void);
void init_CTM_for_delay(void);
void precise_delay_us(unsigned int us);
void start(void);
void stop(void);
void writeByte(unsigned char data);
void sendCommand(unsigned char cmd);
void updateDisplay(void);
void clearDisplay(void);
void toggle_led(unsigned char x, unsigned char y);
void turn_off_led(unsigned char x, unsigned char y);
void generate_carrier_pulse(unsigned int duration_us);
void process_k1_sequence(void);
void process_touch_keys(void);
void process_gesture_logic(void);
void display_custom_number(unsigned int number);
void clear_custom_number_area(void);
void process_seven_segment_logic(void);
void process_k1_shutdown_sequence(void);

// =============================================================================
//                       INTERRUPT SERVICE ROUTINES
// =============================================================================

void __attribute__((interrupt(0x1C))) PTM_Timer_ISR(void) {
    static unsigned char app_tick_counter = 0;
    if (_ptmaf) _ptmaf = 0;
    if (++app_tick_counter >= TICKS_PER_APP_TICK) { app_tick_counter = 0; app_tick_flag = 1; }
}

void __attribute__((interrupt(0x34))) Multi_Function_ISR(void) {
    if (_stmaf) {
        _stmaf = 0;
        IR_EMITTER_PORT = ~IR_EMITTER_PORT;
    }
}

// =============================================================================
//                        CORE FIRMWARE LOGIC
// =============================================================================

void precise_delay_us(unsigned int us) {
    unsigned int target_ticks = us << 1;  // CTM clock = 2MHz, 0.5us/tick, so us * 2 ticks

    if (target_ticks > 1023) target_ticks = 1023;  // CTM is 10-bit max

    _cton = 0;  // Stop CTM
    _cton = 1;  // Start CTM (resets counter)

    unsigned int current_ticks;
    unsigned char high_byte, low_byte;

    while (1) {
        high_byte = _ctmdh;
        low_byte = _ctmdl;
        current_ticks = ((unsigned int)high_byte << 8) | low_byte;

        if (current_ticks >= target_ticks) break;
    }

    _cton = 0;  // Stop CTM
}

void start() { _pc6 = 1; _pc7 = 1; precise_delay_us(5); _pc7 = 0; precise_delay_us(5); _pc6 = 0; precise_delay_us(5); }
void stop() { _pc6 = 0; _pc7 = 0; precise_delay_us(5); _pc6 = 1; precise_delay_us(5); _pc7 = 1; precise_delay_us(5); }
void writeByte(unsigned char data) { unsigned char i; for (i = 0; i < 8; i++) { _pc6 = 0; precise_delay_us(5); if (data & 0x01) { _pc7 = 1; } else { _pc7 = 0; } precise_delay_us(5); _pc6 = 1; precise_delay_us(5); data >>= 1; } }
void sendCommand(unsigned char cmd) { start(); writeByte(cmd); stop(); }
void updateDisplay() { unsigned char i; sendCommand(CMD_DATA_AUTO_INC); start(); writeByte(CMD_ADDRESS_SET | 0x00); for (i = 0; i < 16; i++) { writeByte(displayBuffer[i]); } stop(); }
void clearDisplay() { unsigned char i; for (i = 0; i < 16; i++) { displayBuffer[i] = 0x00; } }
void toggle_led(unsigned char x, unsigned char y) { if (x >= 8 || y >= 16) return; displayBuffer[y] ^= (1 << x); }
void turn_off_led(unsigned char x, unsigned char y) { if (x >= 8 || y >= 16) return; displayBuffer[y] &= ~(1 << x); }

void generate_carrier_pulse(unsigned int duration_us) {
    _ston = 1; // Start the hardware timer (STM)
    precise_delay_us(duration_us);
    _ston = 0; // Stop the hardware timer
    IR_EMITTER_PORT = 0; // Ensure emitter is off after the burst
}

void process_gesture_logic(void) {
    unsigned char r1_active, r2_active;
    if (k1_state == K1_STATE_SEQUENTIAL_ON || k1_state == K1_STATE_SEQUENTIAL_OFF) return;
    if (gesture_cooldown_counter > 0) return;
    
    _emi = 0; generate_carrier_pulse(500);
    r1_active = !IR_RECEIVER_1;
    r2_active = !IR_RECEIVER_2;
    _emi = 1;
    
    switch (gesture_state) {
        case GESTURE_IDLE:
            if (r1_active && !r2_active) { gesture_state = GESTURE_ARMED_R1; gesture_timeout_counter = 0; } 
            else if (r2_active && !r1_active) { gesture_state = GESTURE_ARMED_R2; gesture_timeout_counter = 0; }
            break;
        case GESTURE_ARMED_R1:
            if (r2_active) {
                if (k1_state == K1_STATE_FULLY_ON) {
                    k1_state = K1_STATE_SEQUENTIAL_OFF;
                    seven_seg_mode_on = 0;
                    k1_sequential_index = (sizeof(sequentialOnLeds) / sizeof(LedCoord)) - 1;
                    k1_delay_counter = K1_SEQUENTIAL_DELAY;
                }
                gesture_state = GESTURE_IDLE;
                gesture_cooldown_counter = GESTURE_COOLDOWN;
            } 
            else if (++gesture_timeout_counter > GESTURE_TIMEOUT) { gesture_state = GESTURE_IDLE; }
            break;
        case GESTURE_ARMED_R2:
            if (r1_active) {
                if (k1_state == K1_STATE_OFF) {
                    k1_state = K1_STATE_INSTANT_ON;
                }
                gesture_state = GESTURE_IDLE;
                gesture_cooldown_counter = GESTURE_COOLDOWN;
            } 
            else if (++gesture_timeout_counter > GESTURE_TIMEOUT) { gesture_state = GESTURE_IDLE; }
            break;
    }
}

void process_k1_sequence(void) {
    unsigned char i;
    if (k1_state != K1_STATE_INSTANT_ON && k1_state != K1_STATE_SEQUENTIAL_ON) return;
    
    const unsigned char instant_led_count = sizeof(instantOnLeds) / sizeof(LedCoord);
    const unsigned char sequential_led_count = sizeof(sequentialOnLeds) / sizeof(LedCoord);
    const unsigned char exception_count = sizeof(exceptionLeds) / sizeof(LedCoord);

    switch (k1_state) {
        case K1_STATE_INSTANT_ON:
            clearDisplay();
            for (i = 0; i < instant_led_count; i++) { displayBuffer[instantOnLeds[i].grid] |= (1 << instantOnLeds[i].seg); }
            k1_sequential_index = 0;
            k1_delay_counter = K1_SEQUENTIAL_DELAY;
            k1_state = K1_STATE_SEQUENTIAL_ON;
            break;
        case K1_STATE_SEQUENTIAL_ON:
            if (--k1_delay_counter == 0) {
                if (k1_sequential_index < sequential_led_count) {
                    displayBuffer[sequentialOnLeds[k1_sequential_index].grid] |= (1 << sequentialOnLeds[k1_sequential_index].seg);
                    k1_sequential_index++;
                    k1_delay_counter = K1_SEQUENTIAL_DELAY;
                } else {
                    for (i = 0; i < 16; i++) { displayBuffer[i] = 0xFF; }
                    for (i = 0; i < exception_count; i++) { turn_off_led(exceptionLeds[i].seg, exceptionLeds[i].grid); }
                    k1_state = K1_STATE_FULLY_ON;
                }
            }
            break;
    }
}

void process_k1_shutdown_sequence(void) {
    unsigned char i;
    if (k1_state != K1_STATE_SEQUENTIAL_OFF) return;
    if (--k1_delay_counter == 0) {
        k1_delay_counter = K1_SEQUENTIAL_DELAY;
        turn_off_led(sequentialOnLeds[k1_sequential_index].seg, sequentialOnLeds[k1_sequential_index].grid);

        if (k1_sequential_index == 0) {
            const unsigned char instant_led_count = sizeof(instantOnLeds) / sizeof(LedCoord);
            for (i = 0; i < instant_led_count; i++) {
                turn_off_led(instantOnLeds[i].seg, instantOnLeds[i].grid);
            }
            k1_state = K1_STATE_OFF;
            clearDisplay();
        } else {
            k1_sequential_index--;
        }
    }
}

void process_seven_segment_logic(void) {
    if (!seven_seg_mode_on) return;
    if (++seven_seg_autoincrement_counter >= SEVEN_SEG_AUTO_INTERVAL) {
        seven_seg_autoincrement_counter = 0;
        seven_seg_value += SEVEN_SEG_STEP;
        if (seven_seg_value > SEVEN_SEG_MAX_VALUE) { seven_seg_value = 0; }
    }
    display_custom_number(seven_seg_value);
}

void process_touch_keys(void) {
    if(SCAN_CYCLEF){
        GET_KEY_BITMAP();
        // Swapped: Original K1 action now on K6 (power on/off sequence)
        if((DATA_BUF[0] & KEY_MASK_K6) && !key_flags[5]){
            key_flags[5] = 1;
            if (k1_state == K1_STATE_OFF) { k1_state = K1_STATE_INSTANT_ON; } 
            else if (k1_state == K1_STATE_FULLY_ON) { 
                k1_state = K1_STATE_SEQUENTIAL_OFF;
                seven_seg_mode_on = 0; 
                k1_sequential_index = (sizeof(sequentialOnLeds) / sizeof(LedCoord)) - 1;
                k1_delay_counter = K1_SEQUENTIAL_DELAY;
            }
        } else if(!(DATA_BUF[0] & KEY_MASK_K6)){ key_flags[5]=0; }

        // Swapped: Original K2 action now on K5 (change brightness)
        if((DATA_BUF[0] & KEY_MASK_K5) && !key_flags[4] && k1_state == K1_STATE_FULLY_ON){
            key_flags[4]=1;
            brightness_level = (brightness_level + 1) % 3;
            switch (brightness_level) {
                case 0: sendCommand(CMD_DISPLAY_ON_LOW); break;
                case 1: sendCommand(CMD_DISPLAY_ON_MED); break;
                case 2: sendCommand(CMD_DISPLAY_ON_HIGH); break;
            }
        } else if(!(DATA_BUF[0] & KEY_MASK_K5)){ key_flags[4]=0; }

        // Swapped: Original K3 action now on K4 (increment seven_seg_value)
        if((DATA_BUF[0] & KEY_MASK_K4) && !key_flags[3] && k1_state == K1_STATE_FULLY_ON && seven_seg_mode_on){
            key_flags[3]=1;
            seven_seg_value += SEVEN_SEG_STEP;
            if (seven_seg_value > SEVEN_SEG_MAX_VALUE) seven_seg_value = 0;
            seven_seg_autoincrement_counter = 0;
        } else if(!(DATA_BUF[0] & KEY_MASK_K4)){ key_flags[3]=0; }

        // Swapped: Original K4 action now on K3 (decrement seven_seg_value)
        if((DATA_BUF[2] & KEY_MASK_K3) && !key_flags[2] && k1_state == K1_STATE_FULLY_ON && seven_seg_mode_on){
            key_flags[2]=1;
            if (seven_seg_value >= SEVEN_SEG_STEP) seven_seg_value -= SEVEN_SEG_STEP;
            else seven_seg_value = SEVEN_SEG_MAX_VALUE;
            seven_seg_autoincrement_counter = 0;
        } else if(!(DATA_BUF[2] & KEY_MASK_K3)){ key_flags[2]=0; }

        // Swapped: Original K5 action now on K2 (toggle seven_seg_mode_on)
        if((DATA_BUF[1] & KEY_MASK_K2) && !key_flags[1] && k1_state == K1_STATE_FULLY_ON){
            key_flags[1]=1;
            seven_seg_mode_on = !seven_seg_mode_on;
            if (seven_seg_mode_on) { seven_seg_value = 0; seven_seg_autoincrement_counter = 0; } 
            else { clear_custom_number_area(); }
        } else if(!(DATA_BUF[1] & KEY_MASK_K2)){ key_flags[1]=0; }

        // Swapped: Original K6 action now on K1 (toggle specific LED)
        if((DATA_BUF[2] & KEY_MASK_K1) && !key_flags[0] && k1_state == K1_STATE_FULLY_ON){
            key_flags[0]=1;
            toggle_led(5, 11);
        } else if(!(DATA_BUF[2] & KEY_MASK_K1)){ key_flags[0]=0; }
    }
}

void clear_custom_number_area(void) {
    unsigned char i;
    for (i = 0; i < 28; i++) {
        const LedCoord* led = all_seven_seg_leds[i];
        displayBuffer[led->grid] &= ~(1 << led->seg);
    }
}

void display_custom_number(unsigned int number) {
    if (number > 9999) return;
    clear_custom_number_area();

    unsigned char digits[4];
    digits[0] = (number / 1000) % 10;
    digits[1] = (number / 100) % 10; 
    digits[2] = (number / 10) % 10;  
    digits[3] = number % 10;       

    unsigned char i, j;
    for (i = 0; i < 4; i++) {
        unsigned char segment_mask = seven_seg_font[digits[i]];
        for (j = 0; j < 7; j++) {
            if ((segment_mask >> j) & 0x01) {
                const LedCoord* led_to_light = digit_place_map[i][j];
                displayBuffer[led_to_light->grid] |= (1 << led_to_light->seg);
            }
        }
    }
}

// =============================================================================
//                      INITIALIZATION & MAIN LOOP
// =============================================================================
void configure_system_clock(void) { _hircc = 1; while(!_hircf); _scc = 0; }
void configure_io_pins(void) { _pcs15 = 0; _pcs14 = 0; _pcs17 = 0; _pcs16 = 0; SCLK_PORT_CTRL = 0; DIN_PORT_CTRL = 0; _pcs01 = 0; _pcs00 = 0; IR_EMITTER_CTRL = 0; _pcs05 = 0; _pcs04 = 0; _pcs07 = 0; _pcs06 = 0; _pcc2 = 1; _pcpu2 = 1; _pcc3 = 1; _pcpu3 = 1; }
void init_PTM_for_tick(void) { _ptmc0 = 0b00001000; _ptmc1 = 0b00001001; _ptmal = (2000 - 1) & 0xFF; _ptmah = (2000 - 1) >> 8; _pton = 1; }

void init_STM_for_carrier(void) {
    _stmal = 26;
    _stmah = 0;
    _stmc1 = 0b11000001;
    _stmc0 = 0b00000000;
}

void init_CTM_for_delay(void) {
    _ctmc0 = 0b00000000; // CTM Clock = fSYS/4, Timer is initially STOPPED
    _ctmc1 = 0b11000000; // Timer/Counter Mode
}

void USER_PROGRAM_C_INITIAL(void) {
    configure_system_clock();
    configure_io_pins();
    init_PTM_for_tick();
    init_STM_for_carrier();
    init_CTM_for_delay();
    
    _tkm0c0 = (0b1001 << 4) | (0b000 << 3) | 1; _tkm0c1 = (0b00 << 6) | (0b00 << 2);
    _tkm1c0 = 0b00000111; _tkm1c1 = 0b00000000; _tkm2c0 = 0b00000010;
    _tkm2c1 = 0b00000000; _tkm3c0 = 0b00001100; _tkm3c1 = 0b00000000;
    _wdtc = 0b01010111;
    
    _ptmae = 1;
    _stmae = 1;
    _mfe = 1;
    _emi = 1;
    
    sendCommand(CMD_DISPLAY_ON_HIGH);
    clearDisplay();
    updateDisplay();
}

void USER_PROGRAM_C(void) {
    static unsigned char heartbeat_counter = 0;
    if (app_tick_flag) {
        app_tick_flag = 0;
        
        if (gesture_cooldown_counter > 0) gesture_cooldown_counter--;
        
        process_touch_keys();
        process_gesture_logic();
        process_k1_sequence();
        process_k1_shutdown_sequence();
        process_seven_segment_logic();
        
        if (k1_state == K1_STATE_OFF || k1_state == K1_STATE_FULLY_ON) {
            if (++heartbeat_counter >= HEARTBEAT_INTERVAL) {
                heartbeat_counter = 0;
                if (k1_state == K1_STATE_FULLY_ON) toggle_led(5, 11);
            }
        }
        
        updateDisplay();
    }
    GCC_CLRWDT();
}

// --- HALT Mode Handlers ---
void USER_PROGRAM_C_HALT_PREPARE(void) {}
void USER_PROGRAM_C_HALT_WAKEUP(void)  {}
void USER_PROGRAM_C_RETURN_MAIN(void)  {}
